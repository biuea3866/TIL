# 서브클래싱과 서브타이핑
객체지향에서 상속은 2가지의 용도가 존재한다.  
#### 1. 타입 계층
상속은 타입 계층을 정의하여 일반 개념인 부모 클래스, 특수 개념인 자식 클래스로 계층을 분류 할 수 있다.
#### 2. 코드 재사용
상속은 부모 클래스의 코드를 자식 클래스가 재사용할 수 있다.   
다만, 이 재사용성은 부모 클래스의 구현을 알아야 하고 이는 강결합으로 이어진다.   

상속은 코드의 재사용성이 아닌 타입 계층을 목표로 해야 다형성을 가져가면서, 확장 가능하고 유연하게 설계를 할 수 있다.   

## 타입
객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지이고, 객체의 타입은 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다.   
이 메시지의 집합은 인터페이스이고, 외부 클라이언트가 고수준의 인터페이스를 의존하게 하여 자식의 타입이 다를지라도 동일한 타입으로 분류 시킬 수 있다.   
때문에 고수준의 인터페이스에 정의된 공통된 행동들은 자식들이 일관되게 가질 수 있는 행동이어야 클라이언트 관점에서 의미있는 문맥을 만들 수 있다.   

고수준의 타입인 슈퍼타입은 퍼블릭 인터페이스를 일반화시키고, 저수준의 타입인 서브타입은 퍼블릭 인터페이스를 특수화시킬 수 있다.  
그리고 서브타입은 언제나 슈퍼타입으로 간주될 수 있고, 교체될 수 있는데 이를 다형성이라 부른다.   

## 서브클래싱과 서브타이핑
상속은 is-a 관계에서 사용하는 것이 좋다.  
is-a 관계가 성립한다는 건 문맥, 어휘적으로 서브타입이 슈퍼타입을 대체할 수 있다는 의미이다.   
그리고 완벽하게 슈퍼타입을 대체함으로써 클라이언트는 어떤 타입이 오든 자신의 문맥을 이어나갈 수 있다.   

다만 항상 완벽하게 어휘적으로, 문맥적으로 서브타입이 슈퍼타입을 대체하기 힘들다.   
섣부르게 is-a 관계로 판별하고, 타입을 정의하면 다음과 같은 문제가 발생한다.

```kotlin
interface File {
    fun exportPdf()
}

class Word : File {
    override fun exportPdf() {
        ...
    }
}

class Excel : File {
    override fun exportPdf() {
        ...
    }
}
```
File 인터페이스는 Word, Excel에 상속되었으나 Excel은 pdf로 export가 불가하다.   
단순 파일이라는 문맥적 관점에서는 어느 파일 타입이든지 관계가 없어보이지만 실제로 Excel엔 exportPdf라는 문맥이 어울리지 않는다.   
결국 슈퍼타입, 서브타입 간 호환되어야만 타입 계층으로 묶을 수 있다.

이 문제를 해소하기 위해 다양한 시도를 해볼 수 있다.

#### 1. 내부 구현 비우기
```kotlin
class Excel : File {
    override fun exportPdf() {
    }
}
```

#### 2. 예외 던지기
```kotlin
class Excel : File {
    override fun exportPdf() {
        throw UnsupportedException()
    }
}
```

#### 3. 분기 처리
```kotlin
class FileFactory(private val lists: List<File>) {
    fun exportPdf() {
        lists.forEach { file ->
            if (file is Word) file.exportPdf()
        }
    }
}
```

이 3가지 시도 전부 어떻게든 처리를 할 수 는 있어보이나 가장 큰 단점은 새로운 타입이 추가될 때마다 위와 같은 구현을 매번 해주어야 하는 것이다.   
구현을 매번 해준다는 것은 불필요한 코드 작업이 발생함을 의미하고, 클라이언트 입장에서는 이유 없이 동작을 하지 않는다던지 에러가 레이즈된다던지와 같은 상황을 마주할 수 있다.   

그래서 클라이언트 관점에서 문제를 해소해줄 필요가 있다.   

### 클라이언트 관점에서 문제 해결

#### 1. 타입으로만 사용
```kotlin
interface File {
}

class Word : File {
    fun exportPdf() {
        ...
    }
}

class Excel : File {
}
```

File interface에서 메서드를 제거하여 구현을 없애는 방법이다.   
오로지 File은 타입 계층으로만 사용되며, 구현체에서 필요하다면 독자적으로 메서드를 구현하는 방식이다.   
타입 교체를 할 수 있다는 관점에서 좋아보이지만, 다형성을 이용한 행동호환성 (템플릿 메서드, 전략 패턴)에서는 사용할 수 없다는 것이 단점이다.

#### 2. 기능별 인터페이스 분리

```kotlin
interface PdfExporter {
    fun exportPdf()
}

class Word: PdfExporter {
    override fun exportPdf() {}
}

class Excel
```
기능별로 인터페이스를 분리하고, 단독 오퍼레이션을 구현시킴으로써 클라이언트는 필요한 인터페이스를 의존하여 행동호환성을 지켜나갈 수 있다.    
이를 인터페이스 분리 원칙이라 부르고, 영향에 대한 파급효과를 기능별 인터페이스로 국한시킬 수 있다.

### 서브클래싱과 서브타이핑
그렇다면 상속을 어떻게 하는 것이 올바르고, 올바르지 않은 것인지를 알아나갈 필요가 있다.

#### 1. 서브클래싱
상속을 통해 부모의 코드를 재사용할 목적으로 상속한다.

#### 2. 서브타이핑
부모클래스를 상속받아 타입으로써만 사용한다.

앞서 설명되었던 것처럼 서브클래싱은 부모의 구현을 알아야하고, 이 강결합은 변화에 영향을 준다.   
따라서 되도록 서브타이핑 형태로 타입을 계층화시킬 때 상속을 시키는 것이 좋고, 인터페이스와 추상 클래스 형태로 상속을 시켜 서브 타입이 구현 원본체를 오버라이드하는 일은 없어야 한다.   
그리고 서브타이핑은 개념적으로 슈퍼타입을 완전히 대체할 수 있으므로 이는 행동 호환성을 만족시키고, 대체 가능성을 포함한다.   

## 리스코프 치환원칙
리스코프 치환원칙은 서브타입이 언제나 기반타입을 대체할 수 있음을 의미한다.   
이는 클라이언트가 서브타입이 되었든, 슈퍼타입이 되었든 자연스럽게 어떤 객체든지 사용할 수 있음을 의미한다.   

## 계약에 의한 설계, 서브타이핑
계약은 클라이언트와 서버가 각자 사전조건, 사후조건을 통해 리스코프 치환원칙을 통해 언제든 타입이 대체되더라도 안전하게 행동을 할 수 있게 하는 장치이다.   
여기서 클라이언트는 슈퍼타입, 서버는 서브타입으로 볼 수 있다.   

```kotlin
abstract class File {
    var exportCount = 0L
    
    fun export() {
        this.preCondition()
        this.exportFile()
        exportCount++
    }
    
    private fun preCondition() {
        if (this.exportCount <= -1) throw IllegalStateException()
    }
    
    protected fun exportFile()
}

class MustExportCountGreaterThanZeroFile : File {
    override fun exportFile() {
        this.postCondition()
    }
    
    private fun postCondition() {
        if (this.exportCount < 0) throw IllegalStateException()
    }
}
```
추상 클래스인 File은 preCondition(사전 조건)을 통해 클라이언트 관점에서 협력을 위한 장치를 수행하였고, 서브타입은 postCondition(사후 조건)을 통해 자신이 처리할 수 있는 장치를 수행하였다.    
이렇듯 각자가 수행할 수 있는 계약을 통해 객체 간의 협력을 안전하게 수행해야 한다.    
