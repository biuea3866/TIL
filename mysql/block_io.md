# [DB] 랜덤 액세스, 블록 I/O, 커버링 인덱스

---
### 무엇을 배웠는가?
* 인덱스를 사용한 조회가 어떻게 **테이블 랜덤 액세스**로 이어지는지
* **Single Block I/O**와 **Multi Block I/O**의 동작
* 커버링 인덱스

---
### 왜 중요하고, 어떤 맥락인가?
단순히 '인덱스를 타면 빠르다'는 생각에서 벗어나 인덱스 스캔의 '실제 비용'이 어디서 발생하는지 이해하는 것이 중요합니다.   
가령 'select *' 조회로 객체를 구성하는 ORM에서 대량의 데이터를 조회할 때 쿼리 성능에 어떤 영향을 줄지를 생각해보고, 실행 계획을 분석하여 더 효율적인 쿼리를 작성할 수 있습니다.

---
### 상세 내용

#### 1. 테이블 랜덤 액세스 (Table Random Access)
인덱스를 사용하는 쿼리의 동작은 보통 2단계로 이루어집니다.

1. **인덱스 스캔**: B-Tree 구조의 인덱스를 탐색하여 조건에 맞는 데이터의 **rowId**(레코드 식별 주소값)를 찾습니다.
2. **테이블 접근**: 찾은`rowId`로 실제 데이터가 저장된 **테이블의 데이터 블록**에 접근하여 나머지 컬럼을 가져옵니다.

여기서 2번 과정이 **테이블 랜덤 액세스**입니다.   
테이블의 데이터는 디스크에 정렬되어 있지 않으므로, `rowId`를 통해 데이터를 가져오는 행위는 디스크의 여러 위치를 오가는 랜덤 I/O를 발생시킵니다. 

#### 2. 블록 I/O와 스캔 방식
디스크 I/O는 **블록(Block)** 이라는 최소 단위로 이루어집니다.   
이 블록을 읽는 방식에 따라 성능이 크게 달라집니다.   

* **Single Block I/O**
  * 한 번의 시스템 콜에 **하나의 블록**만 읽는 방식입니다.
  * 인덱스는 논리적으로 정렬되어 있지만, 물리적으로는 여러 블록에 흩어져 저장됩니다. 따라서 인덱스를 탐색할 때는 한 번에 하나의 블록만 읽는 방식이 사용됩니다.
  * 테이블 랜덤 액세스 역시 이 방식으로 동작합니다.
* **Multi Block I/O**
  * 한 번의 시스템 콜에 **연속된 여러 블록**을 한꺼번에 읽는 방식입니다.
  * 테이블 전체 스캔 시 사용되며, 대량의 데이터를 순차적으로 읽을 때 매우 효율적입니다.

#### 3. 왜 옵티마이저는 인덱스를 포기하는가?
만약 인덱스를 통해 읽어야할 데이터가 매우 많다면 (일반적으로 15 ~ 20% 이상), 수천, 수만 번의 **Single Block I/O**가 발생합니다.   
이는 디스크에 엄청난 부하를 주며 차라리 **Multi Block I/O**로 테이블 전체를 한번에 읽는 것이 효율적일 수 있습니다.   
때문에 옵티마이저는 조회할 데이터가 많다면, 인덱스가 있더라도 의도적으로 **풀 스캔**을 선택할 수 있습니다.

#### 4. 해결책: 커버링 인덱스 (Covering Index)
**커버링 인덱스**는 비싼 테이블 랜덤 액세스를 피할 수 있는 해결책이 될 수 있습니다.

> **커버링 인덱스**: 쿼리에 필요한 **모든 컬럼이 인덱스 정보**에 포함되어 있는 경우입니다.

쿼리가 인덱스만으로 모든 결과를 만들어 낼 수 있으므로, <ins>**테이블에 접근할 필요가 없습니다.**</ins>   
즉, 비효율적인 테이블 랜덤 액세스가 발생하지 않습니다.

#### 예시
- `user` 테이블에 `(name)` 컬럼으로 인덱스가 생성된 상황

1. **커버링 인덱스 활용**
```sql
select name
from user
where name = 'John';
```
- `name`을 찾는 조건과 조회하려는 컬럼 모두 인덱스에 포함되어 있습니다.
- 인덱스 스캔만으로 쿼리가 종료되고, 테이블 접근이 발생하지 않습니다.

2. **테이블 랜덤 액세스**
```sql
select *
from user
where name = 'John';
```
- `name` 인덱스를 통해 `rowId`를 찾지만 `*` (나머지 모든 컬럼) 값을 가져오기 위해 **테이블 랜덤 엑세스**가 발생합니다.
- 만약 `name = 'John'`인 데이터가 1000건 이라면, **1000번의 Single Block I/O**가 추가로 발생합니다.

---

### 요약
* `select *` 처럼 인덱스에 없는 컬럼을 조회하면 **테이블 랜덤 액세스**가 발생하며, 이것이 인덱스 사용 시 성능 부하를 발생시킬 수 있습니다.
* 조회 대상이 많다면, 수많은 **Single Block I/O** 보다 **Multi Block I/O**를 사용하는 풀 스캔이 효율적일 수 있습니다.
* **커버링 인덱스**를 활용하면 테이블 접근을 생략하여 I/O를 극적으로 줄일 수 있으므로, 성능 개선 시 고려해야할 요소입니다.
