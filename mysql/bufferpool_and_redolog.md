# [DB] InnoDB 버퍼 풀의 구조와 동작 원리
- **Tags:** #Database #InnoDB #MySQL #BufferPool #Performance #Caching

---

### 무엇을 배웠는가?
InnoDB의 가장 중요한 메모리 영역인 **버퍼 풀**에 대해 학습했습니다.   
버퍼 풀은 디스크의 데이터 파일이나 인덱스 정보를 메모리에 **캐시**하여 읽기 성능을 향상시키고, **쓰기 작업을 지연**시켜 일괄 처리함으로써 디스크 I/O 병목을 줄이는 핵심적인 역할을 합니다.

---

### 왜 중요하고, 어떤 맥락인가?
만약 모든 레코드 변경이 즉시 디스크에 반영(동기화)된다면, 디스크의 **랜덤 I/O 접근**이 빈번하게 발생하여 데이터베이스 성능이 심각하게 저하됩니다.    
버퍼 풀은 이러한 쓰기 작업을 메모리에서 먼저 처리하고 나중에 일괄적으로 디스크에 쓰는(지연) 방식을 통해, 시스템 전체의 I/O 부담을 줄여줍니다.

---

### 상세 내용

#### 1. 버퍼 풀의 3가지 핵심 리스트
버퍼 풀은 메모리 공간을 `innodb_page_size`(기본 16KB) 단위의 페이지 조각들로 나누어 관리합니다.    
이 페이지들을 효율적으로 관리하기 위해 3가지 종류의 리스트를 사용합니다.

1.  **프리 리스트 (Free List)**
    * 버퍼 풀에서 **비어 있는 페이지들의 목록**을 관리합니다.
    * 사용자 쿼리가 디스크에서 새로운 데이터 페이지를 읽어와야 할 때, 이 리스트에서 빈 페이지를 할당받아 사용합니다.

2.  **LRU 리스트 (읽기 캐시 관리)**
    * 페이지가 얼마나 최근에 사용되었는지를 기준으로 관리하는 리스트입니다.
    * 크게 **MRU(Most Recently Used)** 영역과 **LRU(Least Recently Used)** 영역으로 나뉩니다.
    * **동작 흐름**:
        1.  조회에 필요한 레코드가 버퍼 풀에 있는지 확인합니다.
        2.  **[Hit]** 버퍼 풀에 데이터 페이지가 있었다면, 해당 페이지는 **MRU 리스트의 헤더**로 이동(승급)됩니다.
        3.  **[Miss]** 버퍼 풀에 없다면, 디스크에서 해당 페이지를 읽어와 **LRU 리스트의 헤더**에 추가합니다.
        4.  **[승급]** LRU 영역에 있던 이 페이지가 실제로 읽히게 되면, **MRU 리스트의 헤더**로 승급됩니다.
        5.  **[Eviction]** 자주 읽히는 데이터는 MRU 영역에 계속 머무르고, 오랫동안 사용되지 않은 페이지는 LRU 리스트의 끝으로 밀려나 결국 버퍼 풀에서 제거됩니다.
    * **어댑티브 해시 인덱스**: 자주 접근되는 페이지의 인덱스 키는 '어댑티브 해시 인덱스'에 추가되어, 메모리 상에서 더 빠른 검색을 지원합니다.

3.  **플러시 리스트 (Flush List) (쓰기 관리)**
    * 디스크로 동기화되지 않은 데이터 페이지(더티 페이지)들의 목록을 관리합니다.
    * **동작 흐름**:
        1.  데이터 변경(`INSERT`, `UPDATE` 등)이 발생하면, 디스크에 즉시 쓰지 않습니다.
        2.  대신, 변경 내역을 **리두 로그**에 먼저 기록하고, 버퍼 풀에 있는 데이터 페이지만 변경합니다 (이때 '더티 페이지'가 됨).
        3.  이 더티 페이지는 '플러시 리스트'에 추가됩니다.
        4.  이후 **체크포인트(Checkpoint)** 이벤트가 발생하면, 플러시 리스트의 더티 페이지들이 디스크로 동기화(Flush)됩니다.

#### 2. 버퍼 풀과 리두 로그의 관계
버퍼 풀은 변경되지 않은 **클린 페이지**와 변경된 **더티 페이지**를 모두 관리합니다.    
이 변경 내역은 **리두 로그**에도 기록되는데, 리두 로그 파일은 순환(Circular) 형태로 사용되기 때문에 언젠가는 덮어쓰기가 발생합니다.

따라서 InnoDB는 리두 로그가 덮어쓰여 재사용되기 전에, **체크포인트**를 발생시켜 플러시 리스트의 더티 페이지들을 디스크에 동기화합니다.   
이 과정을 통해 리두 로그의 공간을 확보(재활용)합니다.

#### 3. 버퍼 풀 플러시 (Flush)
* **클리너 스레드**: 더티 페이지를 디스크에 동기화하는 작업은 백그라운드의 **클리너 스레드**(`innodb_page_cleaners`)가 담당합니다.
* **쓰기 폭증 (Write Spikes)**: 더티 페이지가 너무 많으면, 이를 한꺼번에 디스크에 쓰느라 CPU 사용률과 디스크 I/O가 급증하는 **'쓰기 폭증'** 현상이 발생할 수 있습니다.
* **완화**: 이를 방지하기 위해 `innodb_max_dirty_pages_pct_lwm` (low water mark) 변수를 설정하여, 더티 페이지가 일정 비율(e.g., 10%)을 넘으면 클리너 스레드가 조금씩 미리 디스크로 기록하여 쓰기 부하를 분산시킵니다.

---

### 핵심
* 버퍼 풀은 InnoDB 성능의 핵심입니다.
* 읽기(Read)는 **LRU/MRU 리스트**를 통해 자주 사용되는 데이터를 메모리에 유지(캐시)합니다.
* 쓰기(Write)는 **플러시 리스트**와 **리두 로그**를 이용해 디스크 쓰기를 지연시켜(Write-Delay), 랜덤 I/O를 최소화하고 성능을 최적화합니다.