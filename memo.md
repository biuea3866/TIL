# Java, Kotlin
* 컴파일
  * java 컴파일: javac로 자바 소스 코드를 바이토 코드로 변환한다.
  * kotlin 컴파일: kotlinc로 코틀린 소스 코드를 자바 바이트 코드로 변환한다.
* JVM
  * 힙: 객체가 메모리에 할당되고, 생애주기를 거치는 영역이다.
    * 영: 객체가 처음 생성되고, 할당되는 영역이다.
    * 서바이벌: GC 동작 때 영에서 살아남은 객체들이 위치하는 영역이다. 서바이벌에 들어가면 객체 헤더의 age 필드가 증가한다. 
    * 올드: age가 일점 임계치를 넘어설 경우 옮겨지는 영역이다.
    * 메타스페이스: 클래스 메타데이터가 저장되는 영역이다. (메서드 영역)
  * 메서드: 클래스의 메서드와 필드 정보, 바이트코드가 저장되는 영역이다.
  * 스택: 각 스레드마다 존재하며, 메서드 호출 시 프레임이 쌓이고 메서드 종료 시 프레임이 제거되는 영역이다.
  * PC Register: 각 스레드마다 존재하며, 현재 실행 중인 JVM 명령어의 주소를 가리키는 영역이다.
  * 네이티브 메서드: JVM 외부에서 실행되는 네이티브 코드를 위한 영역이다.
  * 실행 엔진
    * 인터프리터: 바이트코드를 한 줄씩 읽어 실행하는 역할을 한다.
    * JIT 컴파일러: 바이트코드를 네이티브 코드로 변환하여 실행 성능을 향상시키는 컴파일러이다. 인터프리터의 속도 문제를 해결한다.
    * 가비지 컬렉터: 힙 메모리에서 더 이상 참조되지 않는 객체를 자동으로 제거하는 역할을 한다.
  * 클래스 로더: 바이트 코드(클래스 정보, 타입, 변수, 메서드 정보)를 메서드 영역에 로딩하고, 자바 명세에 맞는지 검증하고, 값들을 초기화한다.
* JDK: Java Development Kit으로 JRE와 개발 도구(컴파일러, 디버거 등)를 포함한다.
* JRE: Java Runtime Environment로 JVM과 자바 라이브러리 API를 포함한다.

# 스프링
* TOMCAT
  * 웹 애플리케이션 서버로 서블릿 컨테이너 역할을 하여 요청당 쓰레드를 생성하고 관리한다. 그리고 외부 서드 파티와의 연동을 지원한다.
* 요청 처리
  1. 클라이언트로부터 요청이 들어온다.
  2. 톰캣이 요청을 받아 서블릿 컨테이너로 전달한다.
  3. 디스패처 서블릿은 요청을 받고, 핸들러 매핑(스프링이 로드되면서, 맵 형태로 url, 메서드로 매핑)을 통해서 컨트롤러를 찾는다.
  4. 핸들러 어댑터에게 요청을 위임하고, 핸들러 어댑터는 컨트롤러의 메서드를 호출한다.
  5. 컨트롤러는 ModelAndView 객체를 반환한다.
  6. 뷰 리졸버는 응답받은 뷰를 읽어 어떤 jsp, html 파일을 렌더링할지 결정한다.
  7. 클라이언트에게 응답한다.
* 동작 방법
  * 스프링 애플리케이션이 시작되면, 스프링 컨테이너가 생성되고, 컴포넌트 스캔을 통해 빈을 등록한다.
  * 어노테이션 기반으로 AOP 프록시를 생성하고, 의존성 주입(DI)을 수행한다.
  * ApplicationMultiCaster를 통해 이벤트 리스너를 등록하고, 애플리케이션 이벤트를 처리한다.
* AOP
  * 다이나믹 프록시: 인터페이스 기반의 프록시 생성 방법으로, JDK의 Proxy 클래스를 사용한다.
  * CGLIB: 클래스 기반의 프록시 생성 방법으로, 바이트코드 조작 라이브러리(cglib)를 사용하여 프록시 클래스를 생성한다.
* 스프링 컨테이너
  * Bean Factory: 스프링 컨테이너 최상위 인터페이스로 빈의 생성, 관리, 조회, 의존성 주입을 담당한다.
  * Application Context: Bean Factory를 확장한 인터페이스로, 국제화, 이벤트 처리, 리소스 로딩등을 추가로 제공한다.
* DI: 리플렉션으로 인스턴스를 생성하고, 빈들 간의 의존성주입을 수행하고, 생성된 빈을 내부 beanDefinitionMap에 저장한다.
* IOC (Inversion of Control): 제어의 역전으로, 객체의 생성과 생명주기 관리를 스프링 컨테이너가 담당하는 것을 의미한다.
* 스프링 빈: 스프링 컨테이너에 의해 관리되는 객체로, 싱글톤 스코프가 기본이다.
  * 빈 라이프사이클
    1. 빈 생성: 스프링 컨테이너가 빈을 생성한다.
    2. 의존성 주입: 생성된 빈에 필요한 의존성을 주입한다.
    3. 초기화: 빈의 초기화 메서드를 호출한다. (예: @PostConstruct, InitializingBean)
    4. 사용: 애플리케이션에서 빈을 사용한다.
    5. 소멸: 스프링 컨테이너가 종료될 때 빈의 소멸 메서드를 호출한다. (예: @PreDestroy, DisposableBean)
  * 빈 스코프
    * 싱글톤: 스프링 컨테이너 당 하나의 인스턴스만 생성된다. (기본값)
    * 프로토타입: 요청할 때마다 새로운 인스턴스가 생성된다.
    * 요청(Request): HTTP 요청당 하나의 인스턴스가 생성된다. (웹 애플리케이션에서 사용)
    * 세션(Session): HTTP 세션당 하나의 인스턴스가 생성된다. (웹 애플리케이션에서 사용)
    * 애플리케이션(Application): 서블릿 컨텍스트당 하나의 인스턴스가 생성된다. (웹 애플리케이션에서 사용)
* 트랜잭션
  * 선언적 트랜잭션: @Transactional 어노테이션을 사용하여 메서드나 클래스에 트랜잭션 속성을 지정한다.
  * 프로그래밍적 트랜잭션: PlatformTransactionManager를 사용하여 트랜잭션을 수동으로 관리한다.

# 스프링 배치
* 구성요소
  * job instance: job의 논리적 실행단위를 나타내고, job이 실행될 때마다 새로운 jobinstance가 생성된다.
  * job parameter: job instance를 식별하기 위한 매개변수로, job 실행 시 전달된다.
  * job execution: job instance의 실제 실행을 나타내고, job이 시작되고 종료될 때마다 새로운 job execution이 생성된다.
  * step: job을 구성하는 단위 작업으로, job execution 내에서 실행된다.
  * step execution: step의 실제 실행을 나타내고, step이 시작되고 종료될 때마다 새로운 step execution이 생성된다.
  * job launcher: job을 실행하는 역할을 한다.
  * job repository: job과 step의 실행 상태와 메타데이터를 저장하는 저장소이다.
* Tasklet: 단일 작업 단위를 나타내며, 주로 간단한 작업을 수행하는 데 사용된다.
* chunk: 데이터를 일정 크기로 나누어 처리하는 단위로, 대량의 데이터를 효율적으로 처리할 수 있다. (reader, processor, writer로 구성)

# 웹서버
* 웹서버란: HTTP 요청을 처리하고, 정적 콘텐츠(HTML, CSS, JS, 이미지 등)를 클라이언트에 제공한다.
* 리버스 프록시: 클라이언트의 요청을 받아 내부의 여러 애플리케이션 서버로 전달하고, 응답을 다시 클라이언트에 반환하는 역할을 한다.
* 로드 밸런싱: 여러 서버에 트래픽을 분산시켜 서버 과부하를 방지하고, 가용성을 높인다.
* SSL: 웹서버가 SSL/TLS 암호화를 처리하여 내부 서버로는 평문 HTTP 요청을 전달한다.
* 압축: 웹서버는 응답 데이터를 gzip, deflate 등으로 압축하여 네트워크 대역폭을 절약하고, 전송 속도를 향상시킨다.
* 정적 리소스 관리: 웹서버는 정적 리소스를 효율적으로 제공하기 위해 캐싱, 압축, CDN 연동 등의 기능을 제공한다.

# WAS
* WAS란: 동적 콘텐츠(서블릿, JSP 등)를 처리하고, 데이터베이스와 연동하여 클라이언트 요청에 대한 비즈니스 로직을 수행한다.
* 세션 관리: WAS는 클라이언트의 상태를 유지하기 위해 세션을 생성하고 관리한다.
* 커넥션 풀링: 데이터베이스와의 연결을 미리 생성해두고 재사용하여 성능을 향상시킨다.
* 캐싱: WAS는 자주 사용되는 데이터를 캐싱하여 응답 속도를 향상시킨다.
* 스레드 관리: WAS는 다중 스레드를 효율적으로 관리하여 동시 요청 처리를 최적화한다.

# MySQL
* 인덱스: 데이터 검색 속도를 향상시키기 위해 사용되는 자료구조이다.
  * 클러스터링 인덱스: 테이블의 데이터가 인덱스 순서대로 물리적으로 저장되는 인덱스이다. (프라이머리 키에 자동 생성)
  * 논클러스터링 인덱스: 테이블의 데이터와 별도로 저장되는 인덱스이다. (세컨더리 인덱스)
* 락: 동시성 제어를 위해 사용되는 메커니즘이다.
  * 테이블 락: 테이블 전체에 대한 락으로, 동시성 제어가 어렵다.
  * 행 락: 특정 행에 대한 락으로, 동시성 제어가 용이하다.
  * 낙관적 락: 데이터 충돌이 적을 것으로 예상되는 경우 사용된다. (버전 관리)
  * 비관적 락: 데이터 충돌이 많을 것으로 예상되는 경우 사용된다. (즉시 락 획득)
* 디스크 IO: 데이터베이스에서 데이터를 읽고 쓰는 작업으로, 성능에 큰 영향을 미친다.
* single, multi block io: 디스크에서 데이터를 읽거나 쓸 때 한 번에 처리하는 블록의 수를 의미한다. 멀티 블록 IO는 한 번에 여러 블록을 처리하여 성능을 향상시킨다.
* 랜덤, 시퀀셜 io: 디스크에서 데이터를 읽거나 쓸 때의 접근 패턴을 의미한다. 시퀀셜 IO는 연속된 블록에 접근하여 성능이 좋고, 랜덤 IO는 불규칙한 블록에 접근하여 성능이 떨어진다.
* 트랜잭션: 데이터베이스의 일관성을 유지하기 위한 작업 단위이다.
  * ACID 특성
    * Atomicity(원자성): 트랜잭션의 모든 작업이 성공적으로 완료되거나, 모두 실패해야 한다.
    * Consistency(일관성): 트랜잭션이 완료된 후에도 데이터베이스는 일관된 상태를 유지해야 한다.
    * Isolation(격리성): 동시에 실행되는 트랜잭션은 서로 간섭하지 않아야 한다.
    * Durability(지속성): 트랜잭션이 완료된 후에는 그 결과가 영구적으로 저장되어야 한다.
* 격리수준: 트랜잭션의 독립성을 보장하기 위한 수준이다.
  * READ UNCOMMITTED: 가장 낮은 격리 수준으로, 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있다. (더티 리드 발생)
  * READ COMMITTED: 언두 로그를 이용하여 커밋된 데이터만 읽을 수 있다. (논리적 일관성 보장)
  * REPEATABLE READ: 갭락, MVCC를 이용하여 트랜잭션이 시작된 이후로 읽은 데이터는 변경되지 않는다. (팬텀 리드 방지)
  * SERIALIZABLE: 가장 높은 격리 수준으로, 모든 트랜잭션이 순차적으로 실행되는 것처럼 동작한다. (완전한 독립성 보장)
* 버퍼풀: 디스크 IO를 줄이기 위해 자주 사용되는 데이터를 메모리에 캐싱하는 영역이다.

# Mongo
* 도큐먼트: MongoDB에서 데이터를 저장하는 기본 단위로, JSON과 유사한 BSON 형식으로 표현된다.
* 컬렉션: 도큐먼트의 집합으로, RDBMS의 테이블과 유사한 개념이다.
* 인덱스: 도큐먼트 검색 속도를 향상시키기 위해 사용되는 자료구조이다.
* 샤딩: 대용량 데이터를 분산 저장하고 처리하기 위해 데이터를 여러 서버에 분할 저장하는 메커니즘이다.
* 애그리게이션: 도큐먼트의 집합에 대해 복잡한 데이터 처리를 수행하는 기능이다.

# 카프카
* 프로듀서: 메시지를 생성하여 카프카 토픽에 전송하는 역할을 한다.
  * 직렬화: 메시지의 키와 값을 바이트 배열로 변환하는 과정이다.
  * 파티셔닝: 메시지가 저장될 토픽의 파티션을 결정하는 과정이다.
  * 압축: 네트워크 전송량을 줄이기 위해 메시지를 압축하는 과정이다.
  * 배치 처리: 여러 메시지를 하나의 배치로 묶어 전송하여 성능을 향상시키는 과정이다.
* 컨슈머: 카프카 토픽에서 메시지를 읽어오는 역할을 한다.
  * 오프셋 관리: 컨슈머가 읽은 메시지의 위치를 추적하는 과정이다.
  * 그룹 관리: 여러 컨슈머가 하나의 그룹으로 동작하여 메시지를 분산 처리하는 과정이다.
  * 리밸런싱: 컨슈머 그룹의 멤버가 변경될 때 파티션 할당을 재조정하는 과정이다.
* 브로커: 카프카 클러스터를 구성하는 서버로, 메시지를 저장하고 전달하는 역할을 한다.
* 주키퍼: 카프카 클러스터의 메타데이터를 관리하고, 브로커와 컨슈머 그룹의 상태를 추적하는 역할을 한다.
* 토픽: 메시지가 저장되는 논리적 단위로, 여러 파티션으로 구성될 수 있다.
* 파티션: 토픽 내에서 메시지가 저장되는 물리적 단위로, 메시지는 파티션에 순차적으로 추가된다.
* 레플리케이션: 데이터의 가용성과 내구성을 높이기 위해 메시지를 여러 브로커에 복제하는 메커니즘이다.
* 오프셋: 파티션 내에서 메시지의 위치를 나타내는 고유한 번호이다.
* ISR(In-Sync Replica): 리더 파티션과 동기화된 상태를 유지하는 팔로워 파티션의 집합이다.
* 리더-팔로워 구조: 각 파티션은 하나의 리더와 여러 팔로워로 구성되며, 리더가 모든 읽기/쓰기 요청을 처리한다.