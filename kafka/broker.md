# [Kafka] 카프카 브로커의 역할, 동작 방식

- **tags:** #Kafka # Broker #Zookeeper #KRaft #ZeroCopy

---
### 무엇을 배웠는가?
* 카프카 브로커 구성에 대해서 배웁니다.
* 카프카의 브로커 중 하나가 맡는 컨트롤러의 역할, 메시지 저장 방식을 배웁니다.
* 카프카 브로커와 클러스터 간의 관계, 주키퍼에 대해서 배웁니다. 
* 제로 카피 방식을 통해 어떻게 높은 처리량을 가져가는지 배웁니다.

---
### 왜 중요하고, 어떤 맥락인가?
카프카의 브로커는 단순 메시지 중개를 넘어, 데이터의 저장, 분산, 복제 그리고 고성능 전송을 책임지는 핵심 요소입니다.   
특히 제로 카피같은 내부 최적화를 이용하여 어떻게 대용량 데이터를 빠르고 안정적으로 처리할 수 있는지 파악할 수 있습니다.

---
### 상세 내용
#### 1. 카프카 브로커란?

프로듀서와 컨슈머 사이에서 메시지를 안정적으로 저장하고, 전달하는 역할을 하는 서버(컴포넌트)입니다.

![broker1.png](../img/kafka/broker1.png)

* **주요 설정**
  * `broker.id`: 클러스터 내에서 각 브로커를 식별하는 고유한 숫자
  * `log.dirs`: 프로듀서로부터 받은 메시지를 디스크에 저장할 경로
  * `zookeeper.connect`: 클러스터 메타데이터를 관리하는 주키퍼의 연결 정보
  * `advertised.listeners`: 외부 클라이언트가 접속할 브로커의 주소

#### 2. Worker & Controller

모든 브로커는 메시지를 처리하는 Worker의 역할을 하지만, 그 중 단 하나는 클러스터를 관리하는 Controller의 역할을 겸임합니다.

![broker2.png](../img/kafka/broker2.png)

* **메시지 저장(Worker)**
  * 브로커는 메시지를 **로그** 자료구조 형태로 디스크에 저장합니다.
  * 이 로그들은 물리적으로 **세그먼트**라는 파일 단위로 나뉘어 저장됩니다.
* **컨트롤러(Controller)**
  * 클러스터 내 단 하나의 브로커에게만 부여됩니다.
  * 다른 브로커들의 상태를 주기적으로 헬스 체크합니다.
  * 리더 파티션을 가진 브로커에 장애가 발생하면, 다른 브로커를 새로운 리더로 선출하여 장애를 복구합니다.

#### 3. 제로 카피
제로 카피는 브로커가 디스크의 메시지를 네트워크로 전송할 때, 불필요한 데이터 복사와 CPU의 컨텍스트 스위칭을 제거하여 성능을 극대화하는 기술입니다.

* **전통적인 방식**: 데이터는 `디스크 -> 커널 버퍼 -> 애플리케이션 버퍼 -> 소켓 버퍼 -> 네트워크`순으로 복사되어 전송됩니다.
  * <ins>데이터를 호출하고, 처리하는 주체인 애플리케이션은 데이터를 알아야 소켓 버퍼로 데이터를 전송</ins>하고, 네트워크로 데이터를 전송할 수 있습니다. 이를 위해  커널 버퍼에서 데이터를 읽어 애플리케이션을 거치고 소켓 버퍼로 전송하는 과정이 필요합니다.
  * 별도로 데이터를 애플리케이션에서 가공할 필요가 없다면 굳이 애플리케이션을 거치는 과정은 불필요합니다.
* **제로 카피 방식**: transferTo(Java에서 제공하는 시스템 콜 메서드)를 이용하여 데이터를 `디스크 -> 커널 버퍼 -> 소켓 버퍼 -> 네크워크`순으로 복사하여 전송합니다.
  * transferTo: 애플리케이션을 거치는 과정없이 시스템 콜을 이용하여 바로 커널 버퍼 -> 소켓 버퍼로 데이터를 전송하게 해주는 메서드입니다.  
  * ```java
    // Transfers from src to dst, or returns -2 if kernel can't do that
    private native long transferTo0(FileDescriptor src, long position,
                                    long count, FileDescriptor dst);
    ```
  * 이 과정을 통해 브로커는 불필요한 데이터 복사, 컨텍스트 스위칭을 제거할 수 있습니다.
* **제약 사항**: SSL과 같이 애플리케이션에서 데이터 가공이 필요한 경우 제로 카피를 이용할 수 없습니다.

#### 4. 클러스터와 파티션
카프카 클러스터는 여러 브로커를 묶어 부하를 분산하고 안정성을 높인 시스템입니다.

* **파티션은 브로커 수에 종속되지 않습니다.**
* 예를 들어, 브로커가 3개인 클러스터에 파티션이 9개인 토픽을 운영할 수 있으며, 각 브로커는 3개의 파티션을 담당하게 됩니다.

#### 5. 주키퍼
주키퍼는 분산 시스템의 메타 데이터를 안정적으로 관리하는 외부 시스템입니다.

* **역할**: 카프카는 전통적으로 주키퍼를 이용하여 주요 메타 데이터를 관리합니다.
  * **브로커 목록**: 현재 클러스터에 참여 중인 브로커들의 ID와 위치
  * **토픽 설정**: 각 토픽픠 파티션 갯수, 복제 수 등의 구성 정보
  * **파티션 리더 정보**: 각 파티션의 리더가 어떤 브로커인지에 대한 정보
  * **ACLs (Access Control List)**: 토픽에 대한 읽기 / 쓰기 권한 정보

* **미래(KRaft)** (http://devocean.sk.com/blog/techBoardDetail.do?ID=165711&boardType=techBlog)
  * 최신 카프카에서는 주키퍼에 대한 의존성을 제거하는 KRaft가 등장하였습니다.
  * **전통적인 방식의 문제**
    * 브로커는 메타데이터 정보를 업데이트하기 위해 매번 주키퍼와 통신을 하고, 특히 대규모 클러스터에서는 병목 현상이 발생할 수 있었습니다.
    * 주키퍼와 브로커는 다른 애플리케이션이므로 관리 측면에서 불편을 야기합니다.
  * 카프카 브로커(컨트롤러)들이 직접 메타 데이터를 관리하여, 외부 시스템의 의존성을 줄이고 더 빠르고 단순한 아키텍쳐를 제공합니다. 

### 요약
* **브로커**는 메시지를 저장하고, 전달하는 카프카의 실질적인 일꾼입니다.
* **컨트롤러**는 브로커 중 하나가 맡는 역할로, 클러스터의 상태를 감시하고 장애를 조치하는 감독관입니다.
* **제로 카피**는 불필요한 데이터 복사를 생략하여 카프카의 높은 전송 성능을 보장하는 핵심 기술입니다.
* **주키퍼**는 클러스터의 모든 설정과 상태 정보(메타데이터)를 저장하는 역할을 해왔지만 점차 KRaft모드로 대체되고 있습니다.